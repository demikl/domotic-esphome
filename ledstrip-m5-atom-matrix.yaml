substitutions:
  devicename: ledstrip-matrix
  upper_devicename: Bureau-matrix

packages:
  device_base: !include common/device_base.yaml
  device_esp32: !include common/device_esp32.yaml

esphome:
  name_add_mac_suffix: true
  on_boot:
    priority: -10
    then:
      - lambda: |-
          if (!id(ambiance_inited)) {
            for (int i = 0; i < 32; i++) id(ambiance_seeds)[i] = esp_random();
            id(ambiance_inited) = true;
          }

button:
  - platform: template
    name: "Ambiance Forêt"
    id: ambiance_foret
    on_press:
      - light.turn_on:
          id: matrix
          effect: "Ambiance Forêt"
      - light.turn_on:
          id: porte_bas
          effect: "Ambiance Forêt"
      - light.turn_on:
          id: porte_haut
          effect: "Ambiance Forêt"

  - platform: template
    name: "Ambiance Aquatique"
    id: ambiance_aquatique
    on_press:
      - light.turn_on:
          id: matrix
          effect: "Ambiance Aquatique"
      - light.turn_on:
          id: porte_bas
          effect: "Ambiance Aquatique"
      - light.turn_on:
          id: porte_haut
          effect: "Ambiance Aquatique"

  - platform: template
    name: "Ambiance Cheminée"
    id: ambiance_cheminee
    on_press:
      - light.turn_on:
          id: matrix
          effect: "Ambiance Cheminée"
      - light.turn_on:
          id: porte_bas
          effect: "Ambiance Cheminée"
      - light.turn_on:
          id: porte_haut
          effect: "Ambiance Cheminée"

  - platform: template
    name: "Forêt Lumineuse"
    id: foret_lumineuse
    on_press:
      - light.turn_on:
          id: matrix
          effect: "Forêt Lumineuse"
      - light.turn_on:
          id: porte_bas
          effect: "Forêt Lumineuse"
      - light.turn_on:
          id: porte_haut
          effect: "Forêt Lumineuse"

  - platform: template
    name: "Forêt Scintillante"
    id: foret_scintillante
    on_press:
      - light.turn_on:
          id: matrix
          effect: "Forêt Scintillante"
      - light.turn_on:
          id: porte_bas
          effect: "Forêt Scintillante"
      - light.turn_on:
          id: porte_haut
          effect: "Forêt Scintillante"

  - platform: template
    name: "Éteindre toutes les ambiances"
    id: eteindre_ambiances
    on_press:
      - light.turn_off:
          id: matrix
      - light.turn_off:
          id: porte_bas
      - light.turn_off:
          id: porte_haut

esp32:
  board: pico32

wifi:
  manual_ip:
    static_ip: 192.168.1.206
    gateway: 192.168.1.1
    subnet: 255.255.255.0

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
    name: ${upper_devicename} Button

spi:
  mosi_pin: GPIO25
  clk_pin: GPIO21

# Ambiances as addressable async effects (Option 2)
globals:
  - id: ambiance_seeds
    type: uint32_t[32]
  - id: ambiance_inited
    type: bool
    initial_value: 'false'

light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    pin: GPIO27
    num_leds: 25
    rgb_order: GRB
    name: ${upper_devicename} Led Matrix
    id: matrix
    color_correct: [40%, 40%, 40%]
    effects:
      - addressable_rainbow:
      - addressable_color_wipe:
      - addressable_scan:
      - addressable_twinkle:
      - addressable_random_twinkle:
      - addressable_fireworks:
      - addressable_lambda:
          name: "Ambiance Forêt"
          update_interval: 300ms
          lambda: |-
            const uint32_t t = millis();
            for (int i = 0; i < it.size(); i++) {
              uint32_t seed = id(ambiance_seeds)[i % 32];
              float slow = fmodf((t / 60000.0f) + ((seed & 0xFF) / 255.0f), 1.0f); // très lent
              
              // Cycle de gamme : chaque LED passe par les 3 zones sur une période plus longue
              float zone_cycle = fmodf((t / 180000.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 3 minutes
              
              float hue;
              // Transitions fluides entre les 3 gammes de couleurs
              if (zone_cycle < 0.33f) {
                // Zone amber → mousse (transition douce)
                float local_progress = zone_cycle / 0.33f;
                float base_amber = 30.0f + 10.0f * slow;     // Amber sous-bois
                float base_mousse = 45.0f + 5.0f * slow;     // Mousse jaunâtre  
                hue = base_amber + (base_mousse - base_amber) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
              } else if (zone_cycle < 0.66f) {
                // Zone mousse → vert (transition douce)
                float local_progress = (zone_cycle - 0.33f) / 0.33f;
                float base_mousse = 45.0f + 5.0f * slow;     // Mousse jaunâtre
                float base_vert = 80.0f + 50.0f * slow;      // Vert profond → vert jaunâtre
                hue = base_mousse + (base_vert - base_mousse) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
              } else {
                // Zone vert → amber (bouclage transition douce)
                float local_progress = (zone_cycle - 0.66f) / 0.34f;
                float base_vert = 80.0f + 50.0f * slow;      // Vert profond → vert jaunâtre
                float base_amber = 30.0f + 10.0f * slow;     // Amber sous-bois
                hue = base_vert + (base_amber - base_vert + 360.0f) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
                if (hue > 360.0f) hue -= 360.0f;
              }
              
              float sat = 0.55f + 0.35f * (((seed >> 16) & 0xFF) / 255.0f);
              float bri = 0.25f + 0.5f * (0.5f + 0.5f * sinf((t / 5000.0f) + (i * 0.27f) + (seed & 0x0F)));
              it[i] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (bri * 255.0f));
            }
      - addressable_lambda:
          name: "Ambiance Aquatique"
          update_interval: 400ms
          lambda: |-
            const uint32_t t = millis();
            for (int i = 0; i < it.size(); i++) {
              uint32_t seed = id(ambiance_seeds)[(i * 3) % 32];
              float slow = fmodf((t / 45000.0f) + ((seed & 0xFF) / 255.0f), 1.0f); // houle lente
              float hue = 160.0f + 80.0f * slow; // 160-240 (vert d'eau -> bleu profond)
              // Accent cyan pulsé
              if (((seed >> 8) & 0xFF) < 24 && slow > 0.6f) {
                hue = 190.0f + 30.0f * sinf(t / 3000.0f + i * 0.4f);
              }
              // Rare éclat violet
              if ((((seed >> 10) & 0x3F) == 0) && (t % 20000 < 1200)) {
                hue = 265.0f; // violet court
              }
              float sat = 0.50f + 0.40f * (((seed >> 16) & 0xFF) / 255.0f);
              float shimmer = 0.04f * sinf(t / 700.0f + i * 0.9f + (seed & 0x1F));
              float bri = 0.30f + 0.55f * (0.5f + 0.5f * sinf((t / 8000.0f) + i * 0.19f)) + shimmer;
              if (bri > 1.0f) bri = 1.0f; if (bri < 0.02f) bri = 0.02f;
              it[i] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (bri * 255.0f));
            }
      - addressable_lambda:
          name: "Ambiance Cheminée"
          update_interval: 120ms
          lambda: |-
            const uint32_t t = millis();
            for (int i = 0; i < it.size(); i++) {
              uint32_t seed = id(ambiance_seeds)[(i * 5 + 7) % 32];
              float phase = (t / 900.0f) + i * 0.9f + (seed & 0x1F);
              // chaleur de base
              float heat = 0.4f + 0.6f * (0.5f + 0.5f * sinf(phase));
              // Flicker aléatoire
              if ((random_uint32() & 0x1F) == 0) {
                heat = 1.0f;
              }
              float hue = 15.0f + 25.0f * (1.0f - heat); // plus chaud -> plus vers jaune
              float sat = 0.75f - 0.45f * heat; // quand heat haut -> tire vers blanc
              float bri = 0.15f + 0.85f * heat;
              // étincelle rare
              if ((random_uint32() % 110) == 0) {
                hue = 10.0f; sat = 0.10f; bri = 1.0f;
              }
              if (sat < 0.0f) sat = 0.0f; if (sat > 1.0f) sat = 1.0f;
              if (bri > 1.0f) bri = 1.0f; if (bri < 0.02f) bri = 0.02f;
              it[i] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (bri * 255.0f));
            }
      - addressable_lambda:
          name: "Forêt Lumineuse"
          update_interval: 200ms
          lambda: |-
            const uint32_t t = millis();
            for (int i = 0; i < it.size(); i++) {
              uint32_t seed = id(ambiance_seeds)[i % 32];
              float slow = fmodf((t / 75000.0f) + ((seed & 0xFF) / 255.0f), 1.0f); // cycle lent de base
              
              // Teintes minérales et végétales principales : terre sombre, mousse profonde, écorce
              float base_hue;
              float mineral_cycle = fmodf((t / 120000.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 2 minutes
              if (mineral_cycle < 0.33f) {
                // Terre sombre rougeâtre
                base_hue = 15.0f + 10.0f * slow; // brun-rouge sombre
              } else if (mineral_cycle < 0.66f) {
                // Mousse profonde
                base_hue = 55.0f + 15.0f * slow; // vert-mousse sombre  
              } else {
                // Écorce grise-verte
                base_hue = 35.0f + 20.0f * slow; // brun-vert écorce
              }
              
              // Modulation lente de la teinte de base
              float hue_variation = 8.0f * sinf((t / 25000.0f) + i * 0.31f + ((seed >> 12) & 0xF));
              float hue = base_hue + hue_variation;
              
              // Saturation pour couleurs minérales (pas trop vives mais visibles)
              float sat = 0.45f + 0.25f * (((seed >> 16) & 0xFF) / 255.0f);
              
              // Luminosité de base : jamais nulle, toujours visible
              float base_bri = 0.65f + 0.20f * (0.5f + 0.5f * sinf((t / 18000.0f) + i * 0.23f));
              
              // Incursions lumineuses rapides (rayons de soleil)
              float sunray_chance = ((seed >> 20) & 0xFF) / 255.0f;
              if (sunray_chance < 0.15f) { // 15% des LEDs peuvent avoir des rayons
                float sunray_phase = fmodf((t / 3500.0f) + i * 0.67f + (seed & 0x1F), 1.0f);
                if (sunray_phase < 0.08f) { // courte incursion lumineuse
                  // Teinte dorée-verte pour simuler le soleil à travers feuillage
                  hue = 45.0f + 25.0f * sinf(sunray_phase * 3.14159f / 0.08f);
                  sat = 0.60f + 0.30f * sinf(sunray_phase * 3.14159f / 0.08f);
                  base_bri = 0.70f + 0.30f * sinf(sunray_phase * 3.14159f / 0.08f); // éclat lumineux
                }
              }
              
              // S'assurer que la luminosité ne descend jamais en dessous du seuil
              if (base_bri < 0.65f) base_bri = 0.65f;
              if (base_bri > 1.0f) base_bri = 1.0f;
              
              // Normalisation de la teinte
              if (hue < 0.0f) hue += 360.0f;
              if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
              
              it[i] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));
            }
      - addressable_lambda:
          name: "Forêt Scintillante"
          update_interval: 25ms
          lambda: |-
            // === PARAMETRES CONFIGURABLES ===
            // Flicker chaud
            const float FLICKER_INTERVAL_MIN_MS = 300.0f;    // Intervalle min entre flickers (ms)
            const float FLICKER_INTERVAL_MAX_MS = 1200.0f;   // Intervalle max entre flickers (ms)
            const float FLICKER_DURATION_MIN_MS = 60.0f;     // Durée min du flicker (ms)
            const float FLICKER_DURATION_MAX_MS = 180.0f;    // Durée max du flicker (ms)
            
            // Éclats brillants  
            const float BRILLIANT_INTERVAL_MIN_MS = 4000.0f; // Intervalle min entre éclats (ms)
            const float BRILLIANT_INTERVAL_MAX_MS = 12000.0f;// Intervalle max entre éclats (ms)
            const float BRILLIANT_DURATION_MIN_MS = 80.0f;   // Durée min de l'éclat (ms)
            const float BRILLIANT_DURATION_MAX_MS = 200.0f;  // Durée max de l'éclat (ms)
            
            const uint32_t t = millis();
            for (int i = 0; i < it.size(); i++) {
              uint32_t seed = id(ambiance_seeds)[i % 32];
              
              // Teinte de base végétale : vert à vert-jaune (80° à 120°)
              float base_oscillation = fmodf((t / 45000.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
              float base_hue = 80.0f + 40.0f * (0.5f + 0.5f * sinf(base_oscillation * 2.0f * 3.14159f));
              
              // Modulation lente de la teinte de base
              float hue_drift = 8.0f * sinf((t / 30000.0f) + i * 0.19f + ((seed >> 8) & 0xF));
              float hue = base_hue + hue_drift;
              
              // Saturation végétale
              float sat = 0.60f + 0.25f * (((seed >> 12) & 0xFF) / 255.0f);
              
              // Luminosité de base : 50% à 65%
              float base_bri = 0.50f + 0.15f * (0.5f + 0.5f * sinf((t / 22000.0f) + i * 0.31f + (seed & 0x1F)));
              
              // === FLICKER CHAUD ALEATOIRE ===
              // Génération d'un "hash" pseudo-aléatoire basé sur t et seed pour timing
              uint32_t flicker_hash = (t + seed * 1103515245 + i * 12345) ^ (seed >> 8);
              float flicker_random = (flicker_hash % 1000) / 1000.0f; // 0.0 à 1.0
              
              // Intervalle aléatoire entre flickers
              float flicker_interval = FLICKER_INTERVAL_MIN_MS + flicker_random * (FLICKER_INTERVAL_MAX_MS - FLICKER_INTERVAL_MIN_MS);
              float flicker_cycle = fmodf(t + (seed & 0xFFF), flicker_interval);
              
              // Durée aléatoire du flicker
              float flicker_duration = FLICKER_DURATION_MIN_MS + ((flicker_hash >> 8) % 1000) / 1000.0f * (FLICKER_DURATION_MAX_MS - FLICKER_DURATION_MIN_MS);
              
              if (flicker_cycle < flicker_duration) {
                float flicker_progress = flicker_cycle / flicker_duration;
                float flicker_intensity = 0.25f * sinf(flicker_progress * 3.14159f);
                
                // Teinte aléatoire à chaque flicker
                float hue_random = ((flicker_hash >> 16) % 1000) / 1000.0f;
                hue = 5.0f + 30.0f * hue_random; // rouge profond à orange (5° à 35°)
                sat = 0.70f + 0.20f * flicker_intensity;
                base_bri += flicker_intensity;
              }
              
              // === ECLATS BRILLANTS ALEATOIRES ===
              uint32_t brilliant_hash = (t * 7 + seed * 2654435761 + i * 48271) ^ (seed >> 16);
              float brilliant_random = (brilliant_hash % 1000) / 1000.0f;
              
              // Intervalle aléatoire entre éclats
              float brilliant_interval = BRILLIANT_INTERVAL_MIN_MS + brilliant_random * (BRILLIANT_INTERVAL_MAX_MS - BRILLIANT_INTERVAL_MIN_MS);
              float brilliant_cycle = fmodf(t + ((seed >> 8) & 0xFFF), brilliant_interval);
              
              // Durée aléatoire de l'éclat
              float brilliant_duration = BRILLIANT_DURATION_MIN_MS + ((brilliant_hash >> 8) % 1000) / 1000.0f * (BRILLIANT_DURATION_MAX_MS - BRILLIANT_DURATION_MIN_MS);
              
              if (brilliant_cycle < brilliant_duration) {
                float brilliant_progress = brilliant_cycle / brilliant_duration;
                float brilliant_intensity = sinf(brilliant_progress * 3.14159f);
                hue = 25.0f; // orange brillant
                sat = 0.85f;
                base_bri = 0.80f + 0.20f * brilliant_intensity;
              }
              
              // Limiter la luminosité entre 50% et 100%
              if (base_bri < 0.5f) base_bri = 0.5f;
              if (base_bri > 1.0f) base_bri = 1.0f;
              
              // Normalisation de la teinte
              if (hue < 0.0f) hue += 360.0f;
              if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
              
              it[i] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));
            }

  - platform: spi_led_strip
    id: ledstrip_p9813
    name: ledstrip
    data_rate: 1MHz
    num_leds: 2
  #   effects:
  #     - <<: !include common/light_effect_alarme.yaml
  #     - pulse:
  #     - addressable_rainbow:
  #     - flicker:
  #     - flicker:
  #         name: Flicker more deviant
  #         alpha: 60%
  #     - flicker:
  #         name: Flicker more intense and deviant
  #         intensity: 20%
  #         alpha: 60%
  #     - random:
  #     - addressable_twinkle:
  #     - addressable_random_twinkle:
  #     - addressable_fireworks:
  #     - addressable_fireworks:
  #         name: Fireworks Effect With Random Colors
  #         use_random_color: true
  #     - addressable_fireworks:
  #         name: Very slow Fireworks Effect With Random Colors
  #         use_random_color: true
  #         spark_probability: 20%
  #         fade_out_rate: 90
  #     - addressable_flicker:
  #     - addressable_flicker:
  #         name: Addressable Flicker more intense
  #         intensity: 60%
  #     - addressable_color_wipe:
  #     - addressable_color_wipe:
  #         name: Color Wipe Effect With Custom Values
  #         add_led_interval: 1s
  #     - addressable_lambda:
  #         name: "Fireplace simple"
  #         update_interval: 30ms
  #         lambda: |-
  #           // it.size() - Number of LEDs
  #           // it[num] - Access the LED at index num.
  #           // Set the LED at num to the given r, g, b values
  #           // it[num] = ESPColor(r, g, b);
  #           // Get the color at index num (ESPColor instance)
  #           // it[num].get();

  #           it[0] = ESPHSVColor(30 + random_uint32() % 30, 255, 135 + random_uint32() % 120).to_rgb();
  #           it[1] = ESPHSVColor(random_uint32() % 30, 255, 135 + random_uint32() % 120).to_rgb();
  #           it[2] = ESPHSVColor(42, 255, 135 + random_uint32() % 120).to_rgb();

  - platform: partition
    name: "porte bas"
    id: porte_bas
    segments:
      - id: ledstrip_p9813
        from: 0
        to: 0
    effects:
      - pulse:
      - addressable_lambda:
          name: "Ambiance Forêt"
          update_interval: 300ms
          lambda: |-
            // Partition "porte bas" seed index 30 - Single LED avec transitions
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[30];
            if (it.size() == 0) return;
            
            float slow = fmodf((t / 61000.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float zone_cycle = fmodf((t / 183000.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 3.05 min
            
            float hue;
            if (zone_cycle < 0.33f) {
              float local_progress = zone_cycle / 0.33f;
              float base_amber = 32.0f + 12.0f * slow;
              float base_mousse = 46.0f + 6.0f * slow;
              hue = base_amber + (base_mousse - base_amber) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
            } else if (zone_cycle < 0.66f) {
              float local_progress = (zone_cycle - 0.33f) / 0.33f;
              float base_mousse = 46.0f + 6.0f * slow;
              float base_vert = 78.0f + 42.0f * slow;
              hue = base_mousse + (base_vert - base_mousse) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
            } else {
              float local_progress = (zone_cycle - 0.66f) / 0.34f;
              float base_vert = 78.0f + 42.0f * slow;
              float base_amber = 32.0f + 12.0f * slow;
              hue = base_vert + (base_amber - base_vert + 360.0f) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
              if (hue > 360.0f) hue -= 360.0f;
            }
            
            float sat = 0.60f + 0.30f * (((seed >> 16) & 0xFF) / 255.0f);
            float bri = 0.35f + 0.45f * (0.5f + 0.5f * sinf((t / 5200.0f) + (seed & 0x0F)));
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t)(sat*255.0f), (uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Ambiance Aquatique"
          update_interval: 400ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[30] ^ 0xA55A5A5A;
            if (it.size() == 0) return;
            float slow = fmodf((t / 47000.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float hue = 170.0f + 70.0f * slow;
            if (((seed >> 10) & 0x3F) == 3 && (t % 18000 < 900)) hue = 265.0f;
            float sat = 0.55f + 0.35f * (((seed >> 16) & 0xFF) / 255.0f);
            float bri = 0.30f + 0.55f * (0.5f + 0.5f * sinf((t / 7000.0f) + (seed & 0x1F)));
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t)(sat*255.0f), (uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Ambiance Cheminée"
          update_interval: 120ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[30] ^ 0x55AA55AA;
            if (it.size() == 0) return;
            float heat = 0.45f + 0.55f * (0.5f + 0.5f * sinf((t / 950.0f) + (seed & 0x1F)));
            if ((random_uint32() & 0x1F) == 0) heat = 1.0f;
            float hue = 16.0f + 24.0f * (1.0f - heat);
            float sat = 0.80f - 0.50f * heat;
            float bri = 0.18f + 0.82f * heat;
            if ((random_uint32() % 95) == 0) { hue = 10.0f; sat = 0.05f; bri = 1.0f; }
            if (sat < 0.0f) sat = 0.0f;
            it[0] = ESPHSVColor((uint8_t)hue,(uint8_t)(sat*255.0f),(uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Forêt Lumineuse"
          update_interval: 200ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[30] ^ 0xF0F0F0F0; // seed unique pour cette partition
            if (it.size() == 0) return;
            
            float slow = fmodf((t / 75000.0f) + ((seed & 0xFF) / 255.0f), 1.0f); // cycle lent de base
            
            // Teintes minérales et végétales principales : terre sombre, mousse profonde, écorce
            float base_hue;
            float mineral_cycle = fmodf((t / 120000.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 2 minutes
            if (mineral_cycle < 0.33f) {
              // Terre sombre rougeâtre
              base_hue = 15.0f + 10.0f * slow; // brun-rouge sombre
            } else if (mineral_cycle < 0.66f) {
              // Mousse profonde
              base_hue = 55.0f + 15.0f * slow; // vert-mousse sombre
            } else {
              // Écorce grise-verte
              base_hue = 35.0f + 20.0f * slow; // brun-vert écorce
            }
            
            // Modulation lente de la teinte de base
            float hue_variation = 6.0f * sinf((t / 27000.0f) + ((seed >> 12) & 0xF));
            float hue = base_hue + hue_variation;
            
            float sat = 0.48f + 0.22f * (((seed >> 16) & 0xFF) / 255.0f);
            float base_bri = 0.65f + 0.22f * (0.5f + 0.5f * sinf((t / 20000.0f) + (seed & 0x1F)));
            
            // Rayon de soleil intense mais plus bref
            float sunray_phase = fmodf((t / 3800.0f) + (seed & 0x1F), 1.0f);
            if (sunray_phase < 0.005f) { // très bref : 0.5% du cycle = ~19ms sur 3.8s
              hue = 50.0f + 22.0f * sinf(sunray_phase * 3.14159f / 0.005f);
              sat = 0.62f + 0.28f * sinf(sunray_phase * 3.14159f / 0.005f);
              base_bri = 0.85f + 0.15f * sinf(sunray_phase * 3.14159f / 0.005f);
            }
            
            // Faibles éclats lumineux plus fréquents
            float weak_flash_phase = fmodf((t / 2200.0f) + ((seed >> 4) & 0x1F), 1.0f);
            if (weak_flash_phase < 0.02f) { // éclat bref : 2% du cycle = ~44ms sur 2.2s
              float flash_intensity = 0.15f * sinf(weak_flash_phase * 3.14159f / 0.02f);
              base_bri += flash_intensity; // s'ajoute à la luminosité de base
              // Légère variation vers des tons plus chauds
              hue += 5.0f * flash_intensity;
            }
            
            // S'assurer que la luminosité ne descend jamais en dessous du seuil
            if (base_bri < 0.65f) base_bri = 0.65f;
            if (base_bri > 1.0f) base_bri = 1.0f;
            
            // Normalisation de la teinte
            if (hue < 0.0f) hue += 360.0f;
            if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
            
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));
      - addressable_lambda:
          name: "Forêt Scintillante"
          update_interval: 25ms
          lambda: |-
            // === PARAMETRES CONFIGURABLES PORTE BAS ===
            const float FLICKER_INTERVAL_MIN_MS = 400.0f;    // Intervalle min entre flickers (ms)
            const float FLICKER_INTERVAL_MAX_MS = 1000.0f;   // Intervalle max entre flickers (ms)
            const float FLICKER_DURATION_MIN_MS = 70.0f;     // Durée min du flicker (ms)
            const float FLICKER_DURATION_MAX_MS = 150.0f;    // Durée max du flicker (ms)
            
            const float BRILLIANT_INTERVAL_MIN_MS = 5000.0f; // Intervalle min entre éclats (ms)
            const float BRILLIANT_INTERVAL_MAX_MS = 15000.0f;// Intervalle max entre éclats (ms)
            const float BRILLIANT_DURATION_MIN_MS = 90.0f;   // Durée min de l'éclat (ms)
            const float BRILLIANT_DURATION_MAX_MS = 220.0f;  // Durée max de l'éclat (ms)
            
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[30] ^ 0xABCDEF12; // seed unique pour cette partition
            if (it.size() == 0) return;
            
            // Teinte de base végétale : vert à vert-jaune (85° à 115°)
            float base_oscillation = fmodf((t / 47000.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float base_hue = 85.0f + 30.0f * (0.5f + 0.5f * sinf(base_oscillation * 2.0f * 3.14159f));
            
            // Modulation lente de la teinte de base
            float hue_drift = 6.0f * sinf((t / 32000.0f) + ((seed >> 8) & 0xF));
            float hue = base_hue + hue_drift;
            
            // Saturation végétale
            float sat = 0.65f + 0.20f * (((seed >> 12) & 0xFF) / 255.0f);
            
            // Luminosité de base : 50% à 65%
            float base_bri = 0.50f + 0.15f * (0.5f + 0.5f * sinf((t / 24000.0f) + (seed & 0x1F)));
            
            // === FLICKER CHAUD ALEATOIRE ===
            uint32_t flicker_hash = (t + seed * 1103515245) ^ (seed >> 8);
            float flicker_random = (flicker_hash % 1000) / 1000.0f;
            
            float flicker_interval = FLICKER_INTERVAL_MIN_MS + flicker_random * (FLICKER_INTERVAL_MAX_MS - FLICKER_INTERVAL_MIN_MS);
            float flicker_cycle = fmodf(t + (seed & 0xFFF), flicker_interval);
            
            float flicker_duration = FLICKER_DURATION_MIN_MS + ((flicker_hash >> 8) % 1000) / 1000.0f * (FLICKER_DURATION_MAX_MS - FLICKER_DURATION_MIN_MS);
            
            if (flicker_cycle < flicker_duration) {
              float flicker_progress = flicker_cycle / flicker_duration;
              float flicker_intensity = 0.30f * sinf(flicker_progress * 3.14159f);
              
              float hue_random = ((flicker_hash >> 16) % 1000) / 1000.0f;
              hue = 8.0f + 25.0f * hue_random; // rouge à orange (8° à 33°)
              sat = 0.75f + 0.15f * flicker_intensity;
              base_bri += flicker_intensity;
            }
            
            // === ECLATS BRILLANTS ALEATOIRES ===
            uint32_t brilliant_hash = (t * 7 + seed * 2654435761) ^ (seed >> 16);
            float brilliant_random = (brilliant_hash % 1000) / 1000.0f;
            
            float brilliant_interval = BRILLIANT_INTERVAL_MIN_MS + brilliant_random * (BRILLIANT_INTERVAL_MAX_MS - BRILLIANT_INTERVAL_MIN_MS);
            float brilliant_cycle = fmodf(t + ((seed >> 8) & 0xFFF), brilliant_interval);
            
            float brilliant_duration = BRILLIANT_DURATION_MIN_MS + ((brilliant_hash >> 8) % 1000) / 1000.0f * (BRILLIANT_DURATION_MAX_MS - BRILLIANT_DURATION_MIN_MS);
            
            if (brilliant_cycle < brilliant_duration) {
              float brilliant_progress = brilliant_cycle / brilliant_duration;
              float brilliant_intensity = sinf(brilliant_progress * 3.14159f);
              hue = 20.0f; // orange brillant
              sat = 0.80f;
              base_bri = 0.75f + 0.25f * brilliant_intensity;
            }
            
            // Limiter la luminosité
            if (base_bri < 0.5f) base_bri = 0.5f;
            if (base_bri > 1.0f) base_bri = 1.0f;
            
            // Normalisation de la teinte
            if (hue < 0.0f) hue += 360.0f;
            if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
            
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));


  - platform: partition
    name: "porte haut"
    id: porte_haut
    segments:
      - id: ledstrip_p9813
        from: 1
        to: 1
    effects:
      - pulse:
      - addressable_lambda:
          name: "Ambiance Forêt"
          update_interval: 300ms
          lambda: |-
            // Partition "porte haut" seed index 31 - Single LED avec transitions
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[31];
            if (it.size() == 0) return;
            
            float slow = fmodf((t / 60500.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float zone_cycle = fmodf((t / 181500.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 3.025 min
            
            float hue;
            if (zone_cycle < 0.33f) {
              float local_progress = zone_cycle / 0.33f;
              float base_amber = 34.0f + 11.0f * slow;
              float base_mousse = 47.0f + 4.0f * slow;
              hue = base_amber + (base_mousse - base_amber) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
            } else if (zone_cycle < 0.66f) {
              float local_progress = (zone_cycle - 0.33f) / 0.33f;
              float base_mousse = 47.0f + 4.0f * slow;
              float base_vert = 82.0f + 46.0f * slow;
              hue = base_mousse + (base_vert - base_mousse) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
            } else {
              float local_progress = (zone_cycle - 0.66f) / 0.34f;
              float base_vert = 82.0f + 46.0f * slow;
              float base_amber = 34.0f + 11.0f * slow;
              hue = base_vert + (base_amber - base_vert + 360.0f) * (0.5f + 0.5f * sinf(local_progress * 3.14159f));
              if (hue > 360.0f) hue -= 360.0f;
            }
            
            float sat = 0.58f + 0.32f * (((seed >> 16) & 0xFF) / 255.0f);
            float bri = 0.33f + 0.47f * (0.5f + 0.5f * sinf((t / 5300.0f) + (seed & 0x0F)));
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t)(sat*255.0f), (uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Ambiance Aquatique"
          update_interval: 400ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[31] ^ 0xA55A5A5A;
            if (it.size() == 0) return;
            float slow = fmodf((t / 46500.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float hue = 165.0f + 75.0f * slow;
            if (((seed >> 10) & 0x3F) == 5 && (t % 20000 < 1100)) hue = 268.0f;
            float sat = 0.53f + 0.37f * (((seed >> 16) & 0xFF) / 255.0f);
            float bri = 0.32f + 0.50f * (0.5f + 0.5f * sinf((t / 7200.0f) + (seed & 0x1F)));
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t)(sat*255.0f), (uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Ambiance Cheminée"
          update_interval: 120ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[31] ^ 0x55AA55AA;
            if (it.size() == 0) return;
            float heat = 0.42f + 0.58f * (0.5f + 0.5f * sinf((t / 910.0f) + (seed & 0x1F)));
            if ((random_uint32() & 0x1F) == 0) heat = 1.0f;
            float hue = 17.0f + 23.0f * (1.0f - heat);
            float sat = 0.82f - 0.50f * heat;
            float bri = 0.17f + 0.83f * heat;
            if ((random_uint32() % 105) == 0) { hue = 9.0f; sat = 0.06f; bri = 1.0f; }
            if (sat < 0.0f) sat = 0.0f;
            it[0] = ESPHSVColor((uint8_t)hue,(uint8_t)(sat*255.0f),(uint8_t)(bri*255.0f));
      - addressable_lambda:
          name: "Forêt Lumineuse"
          update_interval: 200ms
          lambda: |-
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[31] ^ 0x0F0F0F0F; // seed unique pour cette partition
            if (it.size() == 0) return;
            
            float slow = fmodf((t / 75000.0f) + ((seed & 0xFF) / 255.0f), 1.0f); // cycle lent de base
            
            // Teintes minérales et végétales principales : terre sombre, mousse profonde, écorce
            float base_hue;
            float mineral_cycle = fmodf((t / 120000.0f) + ((seed >> 8) & 0xFF) / 255.0f, 1.0f); // 2 minutes
            if (mineral_cycle < 0.33f) {
              // Terre sombre rougeâtre
              base_hue = 15.0f + 10.0f * slow; // brun-rouge sombre
            } else if (mineral_cycle < 0.66f) {
              // Mousse profonde
              base_hue = 55.0f + 15.0f * slow; // vert-mousse sombre
            } else {
              // Écorce grise-verte
              base_hue = 35.0f + 20.0f * slow; // brun-vert écorce
            }
            
            // Modulation lente de la teinte de base
            float hue_variation = 6.0f * sinf((t / 27000.0f) + ((seed >> 12) & 0xF));
            float hue = base_hue + hue_variation;
            
            float sat = 0.48f + 0.22f * (((seed >> 16) & 0xFF) / 255.0f);
            float base_bri = 0.65f + 0.22f * (0.5f + 0.5f * sinf((t / 20000.0f) + (seed & 0x1F)));
            
            // Rayon de soleil intense mais plus bref
            float sunray_phase = fmodf((t / 4100.0f) + (seed & 0x1F), 1.0f);
            if (sunray_phase < 0.004f) { // très bref : 0.4% du cycle = ~16ms sur 4.1s
              hue = 52.0f + 20.0f * sinf(sunray_phase * 3.14159f / 0.004f);
              sat = 0.65f + 0.25f * sinf(sunray_phase * 3.14159f / 0.004f);
              base_bri = 0.85f + 0.15f * sinf(sunray_phase * 3.14159f / 0.004f);
            }
            
            // Faibles éclats lumineux plus fréquents
            float weak_flash_phase = fmodf((t / 1900.0f) + ((seed >> 6) & 0x1F), 1.0f);
            if (weak_flash_phase < 0.018f) { // éclat bref : 1.8% du cycle = ~34ms sur 1.9s
              float flash_intensity = 0.12f * sinf(weak_flash_phase * 3.14159f / 0.018f);
              base_bri += flash_intensity; // s'ajoute à la luminosité de base
              // Légère variation vers des tons plus dorés
              hue += 4.0f * flash_intensity;
            }
            
            // S'assurer que la luminosité ne descend jamais en dessous du seuil
            if (base_bri < 0.65f) base_bri = 0.65f;
            if (base_bri > 1.0f) base_bri = 1.0f;
            
            // Normalisation de la teinte
            if (hue < 0.0f) hue += 360.0f;
            if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
            
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));
      - addressable_lambda:
          name: "Forêt Scintillante"
          update_interval: 25ms
          lambda: |-
            // === PARAMETRES CONFIGURABLES PORTE HAUT ===
            const float FLICKER_INTERVAL_MIN_MS = 350.0f;    // Intervalle min entre flickers (ms)
            const float FLICKER_INTERVAL_MAX_MS = 1100.0f;   // Intervalle max entre flickers (ms)
            const float FLICKER_DURATION_MIN_MS = 50.0f;     // Durée min du flicker (ms)
            const float FLICKER_DURATION_MAX_MS = 170.0f;    // Durée max du flicker (ms)
            
            const float BRILLIANT_INTERVAL_MIN_MS = 4500.0f; // Intervalle min entre éclats (ms)
            const float BRILLIANT_INTERVAL_MAX_MS = 13000.0f;// Intervalle max entre éclats (ms)
            const float BRILLIANT_DURATION_MIN_MS = 70.0f;   // Durée min de l'éclat (ms)
            const float BRILLIANT_DURATION_MAX_MS = 180.0f;  // Durée max de l'éclat (ms)
            
            const uint32_t t = millis();
            uint32_t seed = id(ambiance_seeds)[31] ^ 0x12FEDCBA; // seed unique pour cette partition
            if (it.size() == 0) return;
            
            // Teinte de base végétale : vert à vert-jaune (82° à 118°)
            float base_oscillation = fmodf((t / 46500.0f) + ((seed & 0xFF) / 255.0f), 1.0f);
            float base_hue = 82.0f + 36.0f * (0.5f + 0.5f * sinf(base_oscillation * 2.0f * 3.14159f));
            
            // Modulation lente de la teinte de base
            float hue_drift = 7.0f * sinf((t / 29000.0f) + ((seed >> 8) & 0xF));
            float hue = base_hue + hue_drift;
            
            // Saturation végétale
            float sat = 0.62f + 0.23f * (((seed >> 12) & 0xFF) / 255.0f);
            
            // Luminosité de base : 65% à 80%
            float base_bri = 0.65f + 0.15f * (0.5f + 0.5f * sinf((t / 25000.0f) + (seed & 0x1F)));
            
            // === FLICKER CHAUD ALEATOIRE ===
            uint32_t flicker_hash = (t + seed * 1103515245) ^ (seed >> 8);
            float flicker_random = (flicker_hash % 1000) / 1000.0f;
            
            float flicker_interval = FLICKER_INTERVAL_MIN_MS + flicker_random * (FLICKER_INTERVAL_MAX_MS - FLICKER_INTERVAL_MIN_MS);
            float flicker_cycle = fmodf(t + (seed & 0xFFF), flicker_interval);
            
            float flicker_duration = FLICKER_DURATION_MIN_MS + ((flicker_hash >> 8) % 1000) / 1000.0f * (FLICKER_DURATION_MAX_MS - FLICKER_DURATION_MIN_MS);
            
            if (flicker_cycle < flicker_duration) {
              float flicker_progress = flicker_cycle / flicker_duration;
              float flicker_intensity = 0.28f * sinf(flicker_progress * 3.14159f);
              
              float hue_random = ((flicker_hash >> 16) % 1000) / 1000.0f;
              hue = 6.0f + 28.0f * hue_random; // rouge à orange vif (6° à 34°)
              sat = 0.72f + 0.18f * flicker_intensity;
              base_bri += flicker_intensity;
            }
            
            // === ECLATS BRILLANTS ALEATOIRES ===
            uint32_t brilliant_hash = (t * 7 + seed * 2654435761) ^ (seed >> 16);
            float brilliant_random = (brilliant_hash % 1000) / 1000.0f;
            
            float brilliant_interval = BRILLIANT_INTERVAL_MIN_MS + brilliant_random * (BRILLIANT_INTERVAL_MAX_MS - BRILLIANT_INTERVAL_MIN_MS);
            float brilliant_cycle = fmodf(t + ((seed >> 8) & 0xFFF), brilliant_interval);
            
            float brilliant_duration = BRILLIANT_DURATION_MIN_MS + ((brilliant_hash >> 8) % 1000) / 1000.0f * (BRILLIANT_DURATION_MAX_MS - BRILLIANT_DURATION_MIN_MS);
            
            if (brilliant_cycle < brilliant_duration) {
              float brilliant_progress = brilliant_cycle / brilliant_duration;
              float brilliant_intensity = sinf(brilliant_progress * 3.14159f);
              hue = 22.0f; // orange brillant
              sat = 0.82f;
              base_bri = 0.78f + 0.22f * brilliant_intensity;
            }
            
            // Limiter la luminosité
            if (base_bri < 0.65f) base_bri = 0.65f;
            if (base_bri > 1.0f) base_bri = 1.0f;
            
            // Normalisation de la teinte
            if (hue < 0.0f) hue += 360.0f;
            if (hue >= 360.0f) hue = fmodf(hue, 360.0f);
            
            it[0] = ESPHSVColor((uint8_t) hue, (uint8_t) (sat * 255.0f), (uint8_t) (base_bri * 255.0f));
